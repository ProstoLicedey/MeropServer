{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElementSizeChangePoller = void 0;\n/**\n * This class simply takes an element, records its size, and then polls it for\n * size changes every 500 ms. If a size change is detected the onSizeChanged\n * callback is called.\n */\nclass ElementSizeChangePoller {\n  /**\n   * Constructs a new instance, but initially it won't know which element to\n   * watch. You have to call `update` to pass it the element.\n   *\n   * @param onSizeChanged Callback to call when a watched element's size changes.\n   */\n  constructor(onSizeChanged) {\n    this.onSizeChanged = onSizeChanged;\n    this.start = () => {\n      var _a;\n      // Just in case...\n      if (this.timerId) {\n        this.stop();\n      }\n      this.oldSize = (_a = this.element) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n      this.timerId = setInterval(() => {\n        if (!this.element || !this.oldSize) {\n          return;\n        }\n        const {\n          width,\n          height\n        } = this.element.getBoundingClientRect();\n        if (width !== this.oldSize.width || height !== this.oldSize.height) {\n          this.onSizeChanged();\n        }\n      }, 500);\n    };\n    this.stop = () => {\n      if (this.timerId) {\n        clearInterval(this.timerId);\n      }\n      this.timerId = undefined;\n    };\n    this.polling = false;\n  }\n  /**\n   * Stops polling and clears the element that was being watched.\n   */\n  reset() {\n    this.update(undefined, false);\n  }\n  /**\n   * Changes the element being watched and starts or stops polling for size\n   * changes.\n   */\n  update(element, polling) {\n    this.element = element;\n    this.polling = polling;\n    this.stop();\n    if (this.element && this.polling) {\n      this.start();\n    }\n  }\n}\nexports.ElementSizeChangePoller = ElementSizeChangePoller;","map":{"version":3,"names":["ElementSizeChangePoller","constructor","onSizeChanged","start","timerId","stop","oldSize","_a","element","getBoundingClientRect","setInterval","width","height","clearInterval","undefined","polling","reset","update","exports"],"sources":["C:\\Users\\mi200\\WebstormProjects\\Merops\\client\\node_modules\\react-zoomable-ui\\src\\ElementSizeChangePoller.ts"],"sourcesContent":["/**\n * This class simply takes an element, records its size, and then polls it for\n * size changes every 500 ms. If a size change is detected the onSizeChanged\n * callback is called.\n */\nexport class ElementSizeChangePoller {\n  private element?: HTMLDivElement;\n  private timerId?: any;\n  private polling: boolean;\n  private oldSize?: ClientRect;\n\n  /**\n   * Constructs a new instance, but initially it won't know which element to\n   * watch. You have to call `update` to pass it the element.\n   *\n   * @param onSizeChanged Callback to call when a watched element's size changes.\n   */\n  public constructor(private readonly onSizeChanged: () => void) {\n    this.polling = false;\n  }\n\n  /**\n   * Stops polling and clears the element that was being watched.\n   */\n  public reset() {\n    this.update(undefined, false);\n  }\n\n  /**\n   * Changes the element being watched and starts or stops polling for size\n   * changes.\n   */\n  public update(element: HTMLDivElement | undefined, polling: boolean) {\n    this.element = element;\n    this.polling = polling;\n    this.stop();\n\n    if (this.element && this.polling) {\n      this.start();\n    }\n  }\n\n  private start = () => {\n    // Just in case...\n    if (this.timerId) {\n      this.stop();\n    }\n    this.oldSize = this.element?.getBoundingClientRect();\n    this.timerId = setInterval(() => {\n      if (!this.element || !this.oldSize) {\n        return;\n      }\n      const { width, height } = this.element.getBoundingClientRect();\n      if (width !== this.oldSize.width || height !== this.oldSize.height) {\n        this.onSizeChanged();\n      }\n    }, 500);\n  };\n\n  private stop = () => {\n    if (this.timerId) {\n      clearInterval(this.timerId);\n    }\n    this.timerId = undefined;\n  };\n}\n"],"mappings":";;;;;;AAAA;;;;;AAKA,MAAaA,uBAAuB;EAMlC;;;;;;EAMAC,YAAoCC,aAAyB;IAAzB,KAAAA,aAAa,GAAbA,aAAa;IAyBzC,KAAAC,KAAK,GAAG,MAAK;;MACnB;MACA,IAAI,IAAI,CAACC,OAAO,EAAE;QAChB,IAAI,CAACC,IAAI,EAAE;;MAEb,IAAI,CAACC,OAAO,GAAG,CAAAC,EAAA,OAAI,CAACC,OAAO,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,qBAAqB,EAAE;MACpD,IAAI,CAACL,OAAO,GAAGM,WAAW,CAAC,MAAK;QAC9B,IAAI,CAAC,IAAI,CAACF,OAAO,IAAI,CAAC,IAAI,CAACF,OAAO,EAAE;UAClC;;QAEF,MAAM;UAAEK,KAAK;UAAEC;QAAM,CAAE,GAAG,IAAI,CAACJ,OAAO,CAACC,qBAAqB,EAAE;QAC9D,IAAIE,KAAK,KAAK,IAAI,CAACL,OAAO,CAACK,KAAK,IAAIC,MAAM,KAAK,IAAI,CAACN,OAAO,CAACM,MAAM,EAAE;UAClE,IAAI,CAACV,aAAa,EAAE;;MAExB,CAAC,EAAE,GAAG,CAAC;IACT,CAAC;IAEO,KAAAG,IAAI,GAAG,MAAK;MAClB,IAAI,IAAI,CAACD,OAAO,EAAE;QAChBS,aAAa,CAAC,IAAI,CAACT,OAAO,CAAC;;MAE7B,IAAI,CAACA,OAAO,GAAGU,SAAS;IAC1B,CAAC;IA9CC,IAAI,CAACC,OAAO,GAAG,KAAK;EACtB;EAEA;;;EAGOC,KAAKA,CAAA;IACV,IAAI,CAACC,MAAM,CAACH,SAAS,EAAE,KAAK,CAAC;EAC/B;EAEA;;;;EAIOG,MAAMA,CAACT,OAAmC,EAAEO,OAAgB;IACjE,IAAI,CAACP,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACO,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACV,IAAI,EAAE;IAEX,IAAI,IAAI,CAACG,OAAO,IAAI,IAAI,CAACO,OAAO,EAAE;MAChC,IAAI,CAACZ,KAAK,EAAE;;EAEhB;;AAnCFe,OAAA,CAAAlB,uBAAA,GAAAA,uBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}